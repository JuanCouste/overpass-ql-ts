/**
 * Node = 0x0001
 * Way = 0x0010
 * Relation = 0x0100
 * --------
 * NodeWay = 0x0011 ( Node | Way )
 * NodeRelation = 0x0101 ( Node | Relation )
 * WayRelation = 0x0110 ( Way | Relation )
 * NodeWayRelation = 0x0111 ( Node | Way | Relation )
 */
export enum OverpassQueryTarget {
	Node = 1,
	Way = 2,
	/** Node | Way */
	NodeWay = 3,
	Relation = 4,
	/** Node | Relation */
	NodeRelation = 5,
	/** Way | Relation */
	WayRelation = 6,
	/** Node | Way | Relation */
	NodeWayRelation = 7,
	Area = 8,
	Derived = 9,
}

/** Recurse standalone statements take an input set, and produce a result set */
export enum OverpassRecurseStmType {
	/**
	 * All ways that have a node which appears in the input set
	 * All relations that have a node or way which appears in the input set
	 * All relations that have a way which appears in the result set
	 */
	Up,
	/**
	 * All nodes that are part of a way which appears in the input set
	 * All nodes and ways that are members of a relation which appears in the input set
	 * All nodes that are part of a way which appears in the result set
	 */
	Down,
	/**
	 * Additional to {@link OverpassRecurseStmType.Up}, it continues to follow backlinks onto the found relations
	 * until it contains all relations that point to an object in the input or result set.
	 */
	UpRelations,
	/**
	 * Additional to {@link OverpassRecurseStmType.Down}, it continues to follow the membership links including nodes in ways
	 * until for every object in its input or result set all the members of that object are in the result set as well.
	 */
	DownRelations,
}

export enum OverpassOutputVerbosity {
	/** Print only the ids of the elements in the set. */
	Ids,
	/**
	 * Print the minimum information necessary for geometry:
	 *  - nodes: id and coordinates
	 *  - ways: id and the ids of its member nodes
	 *  - relations: id of the relation, and the id, type, and role of all of its members.
	 */
	Geometry,
	/**
	 * Print all information necessary to use the data.
	 * These are also tags for all elements and the roles for relation members.
	 */
	Body,
	/** Print only ids and tags for each element and not coordinates or members. */
	Tags,
	/**
	 * Print everything known about the elements.
	 * Includes everything output by body for each OSM element, as well as the version,
	 * changeset id, timestamp, and the user data of the user that last touched the object.
	 * Derived elements' metadata attributes are also missing for derived elements.
	 */
	Metadata,
}

export enum OverpassOutputGeoInfo {
	/**
	 * Add the full geometry to each object.
	 * This adds coordinates to each node, to each node member of a way or relation,
	 * and it adds a sequence of "nd" members with coordinates to all relations.
	 */
	Geometry,
	/**
	 * Adds only the bounding box of each element to the element.
	 * For nodes this is equivalent to geom. For ways it is the enclosing bounding box of all nodes.
	 * For relations it is the enclosing bounding box of all node and way members, relations as members have no effect.
	 */
	BoundingBox,
	/**
	 * This adds only the centre of the above mentioned bounding box to ways and relations.
	 * Note: The center point is not guaranteed to lie inside the polygon (example).
	 */
	Center,
}

export enum OverpassSortOrder {
	/** Sort by object id */
	Ascending,
	/**
	 * Sort by quadtile index;
	 * This is roughly geographical and significantly faster than order by ids
	 * (derived elements generated by make or convert statements without any geometry will be grouped separately,
	 * only sorted by id).
	 */
	QuadtileIndex,
}
